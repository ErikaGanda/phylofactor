% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gpf.R
\name{gpf}
\alias{gpf}
\title{Generalized phylofactorization - currently skeleton for binomial glm; will expand to exponential, gamma etc. soon.}
\usage{
gpf(Data, tree, X = NULL, frmla = NULL, PartitioningVariables = NULL,
  frmla.phylo = NULL, nfactors = NULL, ncores = NULL, binom.size = 1,
  expfamily = "gaussian", model.fcn = stats::glm,
  objective.fcn = pvDeviance, algorithm = "mix", alpha = 0.2, ...)
}
\arguments{
\item{Data}{data table containing columns of "Species", 'N' (counts, 0<=N<=3), "Sample".}

\item{X}{meta-data containing "Sample" and variables found in \code{frmla}}

\item{frmla}{Formula. If \code{expfamily='binomial'}, must have c(Successes,Failures)~. Otherwise, the variable for data is "Data", e.g. \code{Data~phylo}. Explanatory variables used for phylofactorization must interact with the variable \code{phylo}, e.g. partitioning by pH and not N requires \code{Data~N+phylo*pH}}

\item{PartitioningVariables}{Character vector containing the variables in \code{frmla} to be used for phylofactorization. Objective function will be the sum of deviance from all variables listed here.}

\item{nfactors}{integer for number of factors to find}

\item{ncores}{integers for number of cores to use for parallelization}

\item{binom.size}{binom.size of binomial samples for each species. binom.size=1 for presence/absence data.}

\item{expfamily}{Either "gaussian" or "binomial" - determines the aggregation method.}

\item{model.fcn}{Regression function, such as glm, gam, glm.nb, gls. Must have column labelled "Deviance" in \code{\link{anova}}.}

\item{algorithm}{Character, either "CoefContrast", "phylo", "mStable" or "mix". "CoefContrast" will partition the standardized coefficient matrix; "phylo" will produce \code{phylo} factors, "mStable" will use \code{phylo} factors for aggregated groups, and "mix" will use coefficient contrasts to identify the top alpha percent of edges and subsequently use the "phylo" algorithm for edge selection.}

\item{alpha}{Numeric between 0 and 1 (strictly greater than 0), indicating the top quantile of edges to use when \code{algorithm=='mix'}. Default is alpha=0.2}
}
\description{
Generalized phylofactorization - currently skeleton for binomial glm; will expand to exponential, gamma etc. soon.
}
\examples{
library(phylofactor)

ilogit <- function(eta) 1/(1+exp(-eta))
set.seed(1)
m <- 50
n <- 200
tree <- rtree(m)
X <- data.table('y'=rnorm(n),
                'z'=rnorm(n,sd=0.5),
                'Sample'=sapply(1:n,FUN=function(s) paste('Sample',s)),
                key='Sample')
#we'll partition by 'y'.
binom.size=3
clade <- phangorn::Descendants(tree,75,'tips')[[1]]
clade2 <- phangorn::Descendants(tree,53,'tips')[[1]]

######## presence/absence dataset with affected clade #######
## most species have higher P{present} with y
eta <- X$z+X$y
p <- ilogit(eta)
M <- matrix(rbinom(m*n,binom.size,rep(p,times=m)),nrow=m,ncol=n,byrow=T)
rownames(M) <- tree$tip.label
colnames(M) <- X$Sample

#### the first clade decreases with y ####
eta1 <- X$z-X$y
p1 <- ilogit(eta1)
for (species in clade){
   M[species,] <- rbinom(n,binom.size,p1)
}
#### the second clade weakly decreases with y ####
eta2 <- X$z-.3*X$y
p2 <- ilogit(eta2)
for (species in clade2){
   M[species,] <- rbinom(n,binom.size,p2)
}

#### Default algorithm: 'mix' #####
### For default can input data matrix or data frame with "Species", "Sample", and all relevant meta-data
DF <- matrix.to.phyloframe(M,data.name='Successes')
DF[,Failures:=binom.size-Successes]
setkey(DF,Sample)
DF <- DF[X]

### DF must have "Species", "Sample", and the LHS of the formula input.
### A separate data frame or data table, X, can have "Sample" and the RHS of the formula.

### The default algorithm is "mix", which uses CoefContrast to limit the number of edges for selection by algorithm 'phylo'
### This algorithm has the greatest power but is also computationally intensive.
### It's recommended that you input both frmla (used in CoefContrst) and frmla.phylo (used in algorithm 'phylo').
### For species-specific effects in algorithm 'phylo', you can use the variable "Species", e.g.
### frmla.phylo=cbind(Successes,Failures)~Species*z+phylo*y. For universal/shared coefficients for "z" across species, simply use
### frmla.phylo=cbind(Successes,Failures)~z+phylo*y

pf <- gpf(DF,tree,frmla=cbind(Successes,Failures)~z+y,
                  frmla.phylo=cbind(Successes,Failures)~z+phylo*y,
                    PartitioningVariables='y',
                    family=binomial,
                    nfactors=2,
                    ncores=2)
all.equal(pf$groups[[1]][[1]],clade) & all.equal(pf$groups[[2]][[1]],clade2)
### Algorithms "phylo", "mix", and "mStable" have a fairly high percent of the computation which is parallelizable.                   

                    
### Another algorithm is "CoefContrast". For this algorithm, you need to input the frmla and Partitioning Variables
 ### CoefContrast is extremely fast and best done without parallelization (as it is built off matrix multiplication).
pf <- gpf(DF,tree,frmla=cbind(Successes,Failures)~z+y,
                    PartitioningVariables='y',
                    algorithm='CoefContrast',
                    family=binomial,
                    nfactors=2)
all.equal(pf$groups[[1]][[1]],clade) & all.equal(pf$groups[[2]][[1]],clade2)

####################### to partition on y, must have phylo* #########
pf <- gpf(M,tree,X,frmla.phylo=cbind(Successes,Failures)~z+phylo*y,nfactors=2,
          binom.size=binom.size,family=binomial(link='logit'),
          PartitioningVariables='y',algorithm='mStable')
all.equal(pf$groups[[1]][[1]],clade) & all.equal(pf$groups[[2]][[1]],clade2)

pf.tree(pf)
par(mfrow=c(2,1))
phytools::phylo.heatmap(tree,M[,order(X$y)])
phytools::phylo.heatmap(tree,ilogit(pf.predict(pf)[,order(X$y)]))

################# Poisson Regression
set.seed(1)
eta <- 2*X$z+X$y
lambda <- exp(eta)
M <- matrix(rpois(m*n,rep(lambda,times=m)),nrow=m,ncol=n,byrow=T)
rownames(M) <- tree$tip.label
colnames(M) <- X$Sample

#### the first clade decreases with y ####
eta1 <- .3*X$z-X$y
lambda1 <- exp(eta1)
for (species in clade){
   M[species,] <- rpois(n,lambda1)
}
#### the second clade strongly increases with y ####
eta2 <- .3*X$z-X$y
lambda2 <- exp(eta2)
for (species in clade2){
   M[species,] <- rpois(n,lambda2)
}



##For non-binomial, use "Data" as response variable #########
pf <- gpf(M,tree,X,frmla.phylo=Data~phylo*(z+y),nfactors=2,family=poisson,
          PartitioningVariables='y',algorithm='mStable')
pf$factors
all.equal(pf$groups[[1]][[1]],clade) & all.equal(pf$groups[[2]][[1]],clade2)

par(mfrow=c(2,1))
phytools::phylo.heatmap(tree,M[,order(X$y)])
phytools::phylo.heatmap(tree,exp(pf.predict(pf)[,order(X$y)]))

### partition vector of data controlling for sample effort ###
set.seed(1)
effort <- rnorm(50)
eta <- effort-3
eta[clade] <- eta[clade]+6
eta[clade2] <- eta[clade2]+8
Data <- data.table('Species'=tree$tip.label,effort,'Successes'=rbinom(50,1,ilogit(eta)),'Sample'=1)
Data$Failures <- 1-Data$Successes
pf <- gpf(Data,tree,frmla.phylo=cbind(Successes,Failures)~effort+phylo,
          nfactors=2,algorithm='phylo',family=binomial)
all.equal(pf$groups[[1]][[1]],clade) & all.equal(pf$groups[[2]][[1]],clade2)
}
